from fastapi import FastAPI, HTTPException, Depends, Query, Body, Header, Request
from fastapi.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
from typing import List, Dict, Any, Optional
import logging
import os
import json
import time
import uuid
from datetime import datetime
from dotenv import load_dotenv
from pathlib import Path

# Load environment variables
ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# MongoDB connection
mongo_url = os.environ.get('MONGO_URL')
db_name = os.environ.get('DB_NAME', 'ai_closer_db')
client = AsyncIOMotorClient(mongo_url)
db = client[db_name]

# Import GHL integration
from ghl import GHLIntegration

# Initialize GHL integration
ghl_integration = GHLIntegration()

# Create FastAPI app
app = FastAPI(title="AI Closer API", version="1.0.0")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Root endpoint
@app.get("/api")
async def root():
    return {"message": "Welcome to AI Closer API", "version": "1.0.0"}

# Organization endpoints
@app.get("/api/organizations")
async def get_organizations():
    orgs = await db.organizations.find().to_list(length=100)
    for org in orgs:
        org["id"] = str(org["_id"])
    return orgs

@app.post("/api/organizations")
async def create_organization(org_data: Dict[str, Any]):
    result = await db.organizations.insert_one(org_data)
    org_data["_id"] = result.inserted_id
    return org_data

# Lead endpoints
@app.get("/api/leads")
async def get_leads(org_id: Optional[str] = None):
    query = {"org_id": org_id} if org_id else {}
    leads = await db.leads.find(query).to_list(length=100)
    for lead in leads:
        lead["id"] = str(lead["_id"])
    return leads

@app.post("/api/leads")
async def create_lead(lead_data: Dict[str, Any]):
    result = await db.leads.insert_one(lead_data)
    lead_data["_id"] = result.inserted_id
    return lead_data

@app.get("/api/leads/{lead_id}")
async def get_lead(lead_id: str):
    lead = await db.leads.find_one({"_id": lead_id})
    if not lead:
        raise HTTPException(status_code=404, detail="Lead not found")
    lead["id"] = str(lead["_id"])
    return lead

# Conversation endpoints
@app.get("/api/conversations")
async def get_conversations(lead_id: Optional[str] = None):
    query = {"lead_id": lead_id} if lead_id else {}
    conversations = await db.conversations.find(query).to_list(length=100)
    for convo in conversations:
        convo["id"] = str(convo["_id"])
    return conversations

@app.post("/api/conversations/process")
async def process_message(
    message: str = Body(...),
    lead_id: str = Body(...),
    channel: str = Body(..., description="chat, sms, email, voice"),
    org_id: str = Body(...)
):
    # Get lead data
    lead = await db.leads.find_one({"_id": lead_id})
    if not lead:
        raise HTTPException(status_code=404, detail="Lead not found")
    
    # Mock processing for demo
    conversation_id = str(uuid.uuid4())
    response = "This is a mock response from the AI. In the real implementation, this would be generated by the multi-agent system."
    
    # Store conversation in database
    convo_data = {
        "_id": conversation_id,
        "lead_id": lead_id,
        "channel": channel,
        "agent_type": "mock_agent",
        "message": message,
        "response": response,
        "created_at": datetime.now()
    }
    await db.conversations.insert_one(convo_data)
    
    # Return mock response
    return {
        "conversation": convo_data,
        "agent_used": {
            "type": "mock_agent",
            "name": "Mock Agent",
            "description": "A mock agent for testing"
        },
        "response": {
            "response": response,
            "agent_type": "mock_agent",
            "confidence": 0.95,
            "analysis": {
                "intent_detected": "information_request",
                "sentiment": "neutral",
                "next_best_action": "follow_up"
            },
            "timestamp": datetime.now().isoformat()
        }
    }

# API Keys management
@app.get("/api/settings/api-keys/{org_id}")
async def get_organization_api_keys(org_id: str):
    api_keys = await db.api_keys.find_one({"org_id": org_id})
    if not api_keys:
        return {}
    
    # Mask sensitive data
    masked_keys = {}
    for key_name, key_value in api_keys.items():
        if (key_name.endswith("_api_key") or key_name.endswith("_secret") or key_name.endswith("_client_secret")) and key_value:
            # Show only last 4 characters
            masked_keys[key_name] = "••••••••" + key_value[-4:] if len(key_value) > 4 else "••••"
        else:
            masked_keys[key_name] = key_value
    
    return masked_keys

@app.put("/api/settings/api-keys/{org_id}")
async def update_organization_api_keys(org_id: str, keys_data: Dict[str, Any]):
    keys_data["org_id"] = org_id
    keys_data["updated_at"] = datetime.now()
    
    # Update GHL integration with new credentials if provided
    if "ghl_client_id" in keys_data and "ghl_client_secret" in keys_data and "ghl_shared_secret" in keys_data:
        ghl_integration.set_credentials(
            client_id=keys_data["ghl_client_id"],
            client_secret=keys_data["ghl_client_secret"],
            shared_secret=keys_data["ghl_shared_secret"]
        )
    
    result = await db.api_keys.update_one(
        {"org_id": org_id},
        {"$set": keys_data},
        upsert=True
    )
    
    api_keys = await db.api_keys.find_one({"org_id": org_id})
    
    # Mask sensitive data in response
    masked_result = {}
    for key_name, key_value in api_keys.items():
        if (key_name.endswith("_api_key") or key_name.endswith("_secret") or key_name.endswith("_client_secret")) and key_value:
            # Show only last 4 characters
            masked_result[key_name] = "••••••••" + key_value[-4:] if len(key_value) > 4 else "••••"
        else:
            masked_result[key_name] = key_value
    
    return masked_result

# GHL OAuth endpoints
@app.get("/api/ghl/oauth-url")
async def get_ghl_oauth_url(org_id: str):
    # Get the GHL credentials
    api_keys = await db.api_keys.find_one({"org_id": org_id})
    if not api_keys or "ghl_client_id" not in api_keys:
        raise HTTPException(status_code=400, detail="GHL Client ID not configured")
    
    # Set up GHL integration
    ghl_integration.set_credentials(
        client_id=api_keys["ghl_client_id"],
        client_secret=api_keys.get("ghl_client_secret", ""),
        shared_secret=api_keys.get("ghl_shared_secret", "")
    )
    
    # Generate OAuth URL
    redirect_uri = f"{os.environ.get('FRONTEND_URL', 'http://localhost:3000')}/ghl-callback"
    oauth_url = await ghl_integration.get_oauth_url(redirect_uri)
    
    return {"oauth_url": oauth_url}

@app.post("/api/ghl/oauth-callback")
async def ghl_oauth_callback(org_id: str, code: str):
    # Get the GHL credentials
    api_keys = await db.api_keys.find_one({"org_id": org_id})
    if not api_keys or "ghl_client_id" not in api_keys or "ghl_client_secret" not in api_keys:
        raise HTTPException(status_code=400, detail="GHL OAuth credentials not configured")
    
    # Set up GHL integration
    ghl_integration.set_credentials(
        client_id=api_keys["ghl_client_id"],
        client_secret=api_keys["ghl_client_secret"],
        shared_secret=api_keys.get("ghl_shared_secret", "")
    )
    
    # Exchange code for token
    redirect_uri = f"{os.environ.get('FRONTEND_URL', 'http://localhost:3000')}/ghl-callback"
    try:
        token_data = await ghl_integration.exchange_code_for_token(code, redirect_uri)
        
        # Store tokens in database
        await db.api_keys.update_one(
            {"org_id": org_id},
            {"$set": {
                "ghl_access_token": token_data["access_token"],
                "ghl_refresh_token": token_data["refresh_token"],
                "ghl_token_expires_at": int(time.time()) + token_data["expires_in"],
                "ghl_location_id": token_data.get("locationId", ""),
                "ghl_company_id": token_data.get("companyId", ""),
                "updated_at": datetime.now()
            }}
        )
        
        return {"success": True, "message": "GHL account connected successfully"}
    except Exception as e:
        logger.error(f"Error exchanging GHL OAuth code: {e}")
        raise HTTPException(status_code=500, detail=f"Error connecting GHL account: {str(e)}")

# Enhanced GHL integration endpoints
@app.get("/api/ghl/contacts")
async def get_ghl_contacts(org_id: str, page: int = 1, limit: int = 100):
    """Get contacts from GHL with pagination"""
    await setup_ghl_integration(org_id)
    
    query_params = {
        "page": page,
        "limit": limit
    }
    
    contacts = await ghl_integration.get_contacts(query_params=query_params)
    return {"contacts": contacts}

@app.get("/api/ghl/contacts/{contact_id}")
async def get_ghl_contact(org_id: str, contact_id: str):
    """Get a specific contact from GHL"""
    await setup_ghl_integration(org_id)
    
    contact = await ghl_integration.get_contact(contact_id)
    return {"contact": contact}

@app.post("/api/ghl/contacts")
async def create_ghl_contact(org_id: str, contact_data: Dict[str, Any]):
    """Create a new contact in GHL"""
    await setup_ghl_integration(org_id)
    
    contact = await ghl_integration.create_contact(contact_data)
    return {"contact": contact}

@app.put("/api/ghl/contacts/{contact_id}")
async def update_ghl_contact(org_id: str, contact_id: str, contact_data: Dict[str, Any]):
    """Update a contact in GHL"""
    await setup_ghl_integration(org_id)
    
    contact = await ghl_integration.update_contact(contact_id, contact_data)
    return {"contact": contact}

@app.get("/api/ghl/contacts/{contact_id}/notes")
async def get_ghl_contact_notes(org_id: str, contact_id: str, limit: int = 50):
    """Get notes for a specific contact"""
    await setup_ghl_integration(org_id)
    
    notes = await ghl_integration.get_contact_notes(contact_id, limit=limit)
    return {"notes": notes}

@app.post("/api/ghl/contacts/{contact_id}/notes")
async def add_ghl_contact_note(org_id: str, contact_id: str, note: str = Body(...), user_id: Optional[str] = None):
    """Add a note to a contact"""
    await setup_ghl_integration(org_id)
    
    result = await ghl_integration.add_note_to_contact(contact_id, note, user_id)
    return result

@app.get("/api/ghl/custom-fields")
async def get_ghl_custom_fields(org_id: str):
    """Get custom fields from GHL"""
    await setup_ghl_integration(org_id)
    
    custom_fields = await ghl_integration.get_custom_fields()
    return {"custom_fields": custom_fields}

@app.post("/api/ghl/custom-fields")
async def create_ghl_custom_field(org_id: str, field_data: Dict[str, Any]):
    """Create a custom field in GHL"""
    await setup_ghl_integration(org_id)
    
    custom_field = await ghl_integration.create_custom_field(field_data)
    return {"custom_field": custom_field}

@app.get("/api/ghl/pipelines")
async def get_ghl_pipelines(org_id: str):
    """Get all pipelines"""
    await setup_ghl_integration(org_id)
    
    pipelines = await ghl_integration.get_pipelines()
    return {"pipelines": pipelines}

@app.get("/api/ghl/opportunities")
async def get_ghl_opportunities(org_id: str, contact_id: Optional[str] = None):
    """Get opportunities, optionally filtered by contact ID"""
    await setup_ghl_integration(org_id)
    
    opportunities = await ghl_integration.get_opportunities(contact_id=contact_id)
    return {"opportunities": opportunities}

@app.post("/api/ghl/opportunities")
async def create_ghl_opportunity(org_id: str, opportunity_data: Dict[str, Any]):
    """Create a new opportunity"""
    await setup_ghl_integration(org_id)
    
    opportunity = await ghl_integration.create_opportunity(opportunity_data)
    return {"opportunity": opportunity}

@app.put("/api/ghl/opportunities/{opportunity_id}")
async def update_ghl_opportunity(org_id: str, opportunity_id: str, opportunity_data: Dict[str, Any]):
    """Update an opportunity"""
    await setup_ghl_integration(org_id)
    
    opportunity = await ghl_integration.update_opportunity(opportunity_id, opportunity_data)
    return {"opportunity": opportunity}

@app.put("/api/ghl/opportunities/{opportunity_id}/stage/{stage_id}")
async def move_ghl_opportunity_stage(org_id: str, opportunity_id: str, stage_id: str):
    """Move an opportunity to a different stage"""
    await setup_ghl_integration(org_id)
    
    opportunity = await ghl_integration.move_opportunity_stage(opportunity_id, stage_id)
    return {"opportunity": opportunity}

@app.get("/api/ghl/tasks")
async def get_ghl_tasks(org_id: str, contact_id: Optional[str] = None):
    """Get tasks, optionally filtered by contact ID"""
    await setup_ghl_integration(org_id)
    
    tasks = await ghl_integration.get_tasks(contact_id=contact_id)
    return {"tasks": tasks}

@app.post("/api/ghl/tasks")
async def create_ghl_task(org_id: str, task_data: Dict[str, Any]):
    """Create a new task"""
    await setup_ghl_integration(org_id)
    
    task = await ghl_integration.create_task(task_data)
    return {"task": task}

@app.post("/api/ghl/contacts/{contact_id}/follow-up")
async def create_ghl_follow_up_task(org_id: str, contact_id: str, task_data: Dict[str, Any]):
    """Create a follow-up task for a human agent"""
    await setup_ghl_integration(org_id)
    
    task = await ghl_integration.create_follow_up_task(contact_id, task_data)
    return {"task": task}

@app.get("/api/ghl/contacts/{contact_id}/comprehensive")
async def get_ghl_comprehensive_lead_data(org_id: str, contact_id: str):
    """Get comprehensive data about a lead"""
    await setup_ghl_integration(org_id)
    
    data = await ghl_integration.get_comprehensive_lead_data(contact_id)
    return data

@app.post("/api/ghl/contacts/{contact_id}/ai-insights")
async def update_ghl_ai_insights(org_id: str, contact_id: str, ai_insights: Dict[str, Any]):
    """Update AI-specific insights in GHL custom fields"""
    await setup_ghl_integration(org_id)
    
    result = await ghl_integration.update_ai_insights(contact_id, ai_insights)
    return result

@app.post("/api/ghl/contacts/{contact_id}/ai-interaction")
async def add_ghl_ai_interaction_note(org_id: str, contact_id: str, interaction_data: Dict[str, Any]):
    """Add a structured note about an AI interaction"""
    await setup_ghl_integration(org_id)
    
    result = await ghl_integration.add_ai_interaction_note(contact_id, interaction_data)
    return result

# Helper function to set up GHL integration
async def setup_ghl_integration(org_id: str):
    """Set up GHL integration with the organization's credentials"""
    api_keys = await db.api_keys.find_one({"org_id": org_id})
    if not api_keys:
        raise HTTPException(status_code=400, detail="GHL credentials not found")
    
    # Set credentials
    ghl_integration.set_credentials(
        client_id=api_keys.get("ghl_client_id", ""),
        client_secret=api_keys.get("ghl_client_secret", ""),
        shared_secret=api_keys.get("ghl_shared_secret", "")
    )
    
    # Set tokens if they exist
    if "ghl_access_token" in api_keys and "ghl_refresh_token" in api_keys:
        expires_in = api_keys.get("ghl_token_expires_at", 0) - int(time.time())
        if expires_in < 0:
            expires_in = 0
        
        ghl_integration.set_tokens(
            access_token=api_keys["ghl_access_token"],
            refresh_token=api_keys["ghl_refresh_token"],
            expires_in=expires_in,
            location_id=api_keys.get("ghl_location_id"),
            company_id=api_keys.get("ghl_company_id")
        )

# Placeholder endpoints for the full implementation
@app.get("/api/memory/lead/{lead_id}")
async def get_lead_memory(lead_id: str):
    return {
        "lead_id": lead_id,
        "memory": {
            "factual": {
                "property_preferences": {
                    "bedrooms": 3,
                    "bathrooms": 2,
                    "location": "downtown",
                    "property_type": "condo"
                },
                "budget": {
                    "min": 300000,
                    "max": 450000
                }
            },
            "emotional": {
                "trust_level": 0.7,
                "rapport_level": 0.6
            }
        }
    }

@app.get("/api/agents/config")
async def get_agent_configs():
    return {
        "initial_contact": {
            "name": "Initial Contact Agent",
            "description": "Specializes in first impressions and rapport building",
            "llm_provider": "openai",
            "llm_model": "gpt-4o",
            "temperature": 0.7
        },
        "qualifier": {
            "name": "Qualification Agent",
            "description": "Specializes in lead qualification and needs assessment",
            "llm_provider": "anthropic",
            "llm_model": "claude-3-sonnet",
            "temperature": 0.6
        }
    }

@app.get("/api/knowledge/agent/{agent_type}")
async def get_agent_knowledge(agent_type: str, org_id: str):
    return {
        "examples": [
            {
                "scenario": "Cold call",
                "response": "Hi [Name], this is [Your Name] from [Company]. I noticed you were looking at properties in [Area]. Is this a good time to chat briefly about your real estate needs?"
            }
        ],
        "guidelines": {
            "Initial Contact Best Practices": "When making initial contact with a lead, focus on building rapport and understanding their needs..."
        },
        "common_scenarios": {
            "What is a down payment?": "A down payment is the initial payment made when purchasing a home...",
            "How much do I need for a down payment?": "Typically, you need 3-20% of the purchase price..."
        }
    }

@app.post("/api/ghl/webhook")
async def ghl_webhook(payload: Dict[str, Any], org_id: str, signature: str = Header(None, alias="X-GoHighLevel-Signature"), event_type: str = Header(None, alias="X-Event-Type")):
    logger.info(f"Received GHL webhook: {event_type}")
    
    # Get the organization's GHL credentials
    api_keys = await db.api_keys.find_one({"org_id": org_id})
    if not api_keys or "ghl_shared_secret" not in api_keys:
        logger.warning(f"Organization {org_id} is not properly configured for GHL webhooks")
        raise HTTPException(status_code=400, detail="GHL webhook configuration incomplete")
    
    # Set up GHL integration
    ghl_integration.set_credentials(
        client_id=api_keys.get("ghl_client_id", ""),
        client_secret=api_keys.get("ghl_client_secret", ""),
        shared_secret=api_keys["ghl_shared_secret"]
    )
    
    # Verify webhook signature
    payload_str = json.dumps(payload)
    if signature and not ghl_integration.verify_webhook_signature(signature, payload_str):
        logger.warning(f"Invalid webhook signature for organization {org_id}")
        raise HTTPException(status_code=403, detail="Invalid webhook signature")
    
    # Handle different event types
    if event_type == "contact.created" or event_type == "contact.updated":
        # Process contact creation/update
        await process_contact_webhook(org_id, payload, event_type)
    elif event_type == "opportunity.created" or event_type == "opportunity.updated":
        # Process opportunity creation/update
        await process_opportunity_webhook(org_id, payload, event_type)
    elif event_type == "note.created":
        # Process note creation
        await process_note_webhook(org_id, payload, event_type)
    elif event_type == "task.created" or event_type == "task.updated" or event_type == "task.completed":
        # Process task creation/update/completion
        await process_task_webhook(org_id, payload, event_type)
    elif event_type == "appointment.created" or event_type == "appointment.updated":
        # Process appointment creation/update
        await process_appointment_webhook(org_id, payload, event_type)
    
    # Return a success response
    return {"status": "success", "message": f"Processed {event_type} webhook", "org_id": org_id}

async def process_contact_webhook(org_id: str, payload: Dict[str, Any], event_type: str):
    """Process contact webhook events"""
    contact_data = payload.get("contact", {})
    ghl_contact_id = contact_data.get("id")
    
    if not ghl_contact_id:
        logger.warning("Contact ID missing from webhook payload")
        return
    
    # Check if lead already exists in our system
    existing_lead = await db.get_lead_by_ghl_id(ghl_contact_id)
    
    if existing_lead:
        # Update existing lead
        update_data = {
            "updated_at": datetime.now()
        }
        
        # Map GHL fields to lead profile fields
        if "name" in contact_data:
            update_data["name"] = contact_data["name"]
        
        if "email" in contact_data:
            update_data["email"] = contact_data["email"]
        
        if "phone" in contact_data:
            update_data["phone"] = contact_data["phone"]
        
        # Extract custom fields that may contain AI insights
        if "customField" in contact_data:
            custom_fields = contact_data["customField"]
            
            # Map specific custom fields to our lead profile fields
            ai_field_mapping = {
                "AI Personality Type": "personality_type",
                "AI Trust Level": "trust_level",
                "AI Conversion Score": "conversion_probability",
                "AI Relationship Stage": "relationship_stage",
                "AI Next Best Action": "next_best_action"
            }
            
            for ghl_field, our_field in ai_field_mapping.items():
                if ghl_field in custom_fields:
                    value = custom_fields[ghl_field]
                    
                    # Convert percentage values to decimals
                    if ghl_field in ["AI Trust Level", "AI Conversion Score"]:
                        try:
                            value = float(value) / 100.0
                        except (ValueError, TypeError):
                            pass
                    
                    update_data[our_field] = value
            
            # Extract property preferences
            property_preferences = {}
            budget_analysis = {}
            
            for field_name, field_value in custom_fields.items():
                # Property preferences
                if field_name.startswith("Property "):
                    key = field_name.replace("Property ", "").lower().replace(" ", "_")
                    property_preferences[key] = field_value
                
                # Budget information
                elif field_name == "Budget Minimum":
                    try:
                        budget_analysis["min"] = float(field_value)
                    except (ValueError, TypeError):
                        pass
                elif field_name == "Budget Maximum":
                    try:
                        budget_analysis["max"] = float(field_value)
                    except (ValueError, TypeError):
                        pass
            
            if property_preferences:
                update_data["property_preferences"] = property_preferences
            
            if budget_analysis:
                update_data["budget_analysis"] = budget_analysis
        
        # Extract tags
        if "tags" in contact_data:
            update_data["tags"] = contact_data["tags"]
        
        # Update lead in our database
        await db.update_lead(existing_lead["_id"], update_data)
        
        logger.info(f"Updated lead {existing_lead['_id']} from GHL contact {ghl_contact_id}")
    else:
        # Create new lead
        lead_data = {
            "_id": str(uuid.uuid4()),
            "org_id": org_id,
            "ghl_contact_id": ghl_contact_id,
            "created_at": datetime.now(),
            "updated_at": datetime.now(),
            "relationship_stage": "initial_contact",  # Default stage for new leads
            "trust_level": 0.5,  # Default trust level
            "conversion_probability": 0.0  # Default conversion probability
        }
        
        # Map basic contact fields
        for field in ["name", "email", "phone"]:
            if field in contact_data:
                lead_data[field] = contact_data[field]
        
        # Create lead in our database
        await db.create_lead(lead_data)
        
        logger.info(f"Created new lead for GHL contact {ghl_contact_id}")

async def process_opportunity_webhook(org_id: str, payload: Dict[str, Any], event_type: str):
    """Process opportunity webhook events"""
    opportunity_data = payload.get("opportunity", {})
    
    # Check if the opportunity is associated with a contact
    contact_id = opportunity_data.get("contactId")
    if not contact_id:
        logger.warning("Contact ID missing from opportunity webhook payload")
        return
    
    # Find the lead in our system
    lead = await db.get_lead_by_ghl_id(contact_id)
    if not lead:
        logger.warning(f"Lead not found for GHL contact {contact_id}")
        return
    
    # Update lead's relationship stage based on opportunity stage
    pipeline_stage = opportunity_data.get("pipelineStageId")
    
    # Store the opportunity in the lead's data
    opportunities = lead.get("opportunities", [])
    
    # Check if this opportunity already exists
    existing_opp_index = next((i for i, opp in enumerate(opportunities) if opp.get("id") == opportunity_data.get("id")), None)
    
    if existing_opp_index is not None:
        # Update existing opportunity
        opportunities[existing_opp_index] = opportunity_data
    else:
        # Add new opportunity
        opportunities.append(opportunity_data)
    
    # Update lead with opportunity data
    update_data = {
        "opportunities": opportunities,
        "updated_at": datetime.now()
    }
    
    # If pipeline stage changed, potentially update relationship stage
    if pipeline_stage:
        # Here we would map pipeline stages to relationship stages
        # This is just a placeholder for the real mapping logic
        stage_mapping = {
            # Map GHL pipeline stage IDs to our relationship stages
            # These would be specific to the organization's GHL setup
            # "stage1": "initial_contact",
            # "stage2": "qualification",
            # "stage3": "nurturing",
            # "stage4": "closing"
        }
        
        if pipeline_stage in stage_mapping:
            update_data["relationship_stage"] = stage_mapping[pipeline_stage]
    
    await db.update_lead(lead["_id"], update_data)
    logger.info(f"Updated lead {lead['_id']} with opportunity data")

async def process_note_webhook(org_id: str, payload: Dict[str, Any], event_type: str):
    """Process note webhook events"""
    note_data = payload.get("note", {})
    
    # Check if the note is associated with a contact
    contact_id = note_data.get("contactId")
    if not contact_id:
        logger.warning("Contact ID missing from note webhook payload")
        return
    
    # Find the lead in our system
    lead = await db.get_lead_by_ghl_id(contact_id)
    if not lead:
        logger.warning(f"Lead not found for GHL contact {contact_id}")
        return
    
    # Store the note in the lead's data
    notes = lead.get("notes", [])
    notes.append({
        "id": note_data.get("id"),
        "body": note_data.get("body"),
        "created_at": note_data.get("createdAt") or datetime.now().isoformat(),
        "user_id": note_data.get("userId")
    })
    
    # Update lead with note data
    update_data = {
        "notes": notes,
        "updated_at": datetime.now()
    }
    
    await db.update_lead(lead["_id"], update_data)
    logger.info(f"Updated lead {lead['_id']} with note data")

async def process_task_webhook(org_id: str, payload: Dict[str, Any], event_type: str):
    """Process task webhook events"""
    task_data = payload.get("task", {})
    
    # Check if the task is associated with a contact
    contact_id = task_data.get("contactId")
    if not contact_id:
        logger.warning("Contact ID missing from task webhook payload")
        return
    
    # Find the lead in our system
    lead = await db.get_lead_by_ghl_id(contact_id)
    if not lead:
        logger.warning(f"Lead not found for GHL contact {contact_id}")
        return
    
    # Store the task in the lead's data
    tasks = lead.get("tasks", [])
    
    # Check if this task already exists
    existing_task_index = next((i for i, task in enumerate(tasks) if task.get("id") == task_data.get("id")), None)
    
    if existing_task_index is not None:
        # Update existing task
        tasks[existing_task_index] = task_data
    else:
        # Add new task
        tasks.append(task_data)
    
    # Update lead with task data
    update_data = {
        "tasks": tasks,
        "updated_at": datetime.now()
    }
    
    await db.update_lead(lead["_id"], update_data)
    logger.info(f"Updated lead {lead['_id']} with task data")

async def process_appointment_webhook(org_id: str, payload: Dict[str, Any], event_type: str):
    """Process appointment webhook events"""
    appointment_data = payload.get("appointment", {})
    
    # Check if the appointment is associated with a contact
    contact_id = appointment_data.get("contactId")
    if not contact_id:
        logger.warning("Contact ID missing from appointment webhook payload")
        return
    
    # Find the lead in our system
    lead = await db.get_lead_by_ghl_id(contact_id)
    if not lead:
        logger.warning(f"Lead not found for GHL contact {contact_id}")
        return
    
    # Store the appointment in the lead's data
    appointments = lead.get("appointments", [])
    
    # Check if this appointment already exists
    existing_appt_index = next((i for i, appt in enumerate(appointments) if appt.get("id") == appointment_data.get("id")), None)
    
    if existing_appt_index is not None:
        # Update existing appointment
        appointments[existing_appt_index] = appointment_data
    else:
        # Add new appointment
        appointments.append(appointment_data)
    
    # Update lead with appointment data
    update_data = {
        "appointments": appointments,
        "updated_at": datetime.now()
    }
    
    # If this is a confirmed appointment, potentially update relationship stage
    if appointment_data.get("status") == "confirmed":
        update_data["relationship_stage"] = "closing"  # Move to closing stage when appointment is confirmed
    
    await db.update_lead(lead["_id"], update_data)
    logger.info(f"Updated lead {lead['_id']} with appointment data")

# Shutdown event to close database connection
@app.on_event("shutdown")
async def shutdown_db_client():
    client.close()
