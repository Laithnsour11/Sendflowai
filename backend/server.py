from fastapi import FastAPI, HTTPException, Depends, Query, Body, Header, Request
from fastapi.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
from typing import List, Dict, Any, Optional
import logging
import os
import json
import uuid
from datetime import datetime
from dotenv import load_dotenv
from pathlib import Path
import time

# Load environment variables
ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# MongoDB connection
mongo_url = os.environ.get('MONGO_URL')
db_name = os.environ.get('DB_NAME', 'ai_closer_db')
client = AsyncIOMotorClient(mongo_url)
db = client[db_name]

# Import GHL integration
from ghl import GHLIntegration

# Initialize GHL integration
ghl_integration = GHLIntegration()

# Create FastAPI app
app = FastAPI(title="AI Closer API", version="1.0.0")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Root endpoint
@app.get("/api")
async def root():
    return {"message": "Welcome to AI Closer API", "version": "1.0.0"}

# Organization endpoints
@app.get("/api/organizations")
async def get_organizations():
    orgs = await db.organizations.find().to_list(length=100)
    for org in orgs:
        org["id"] = str(org["_id"])
    return orgs

@app.post("/api/organizations")
async def create_organization(org_data: Dict[str, Any]):
    result = await db.organizations.insert_one(org_data)
    org_data["_id"] = result.inserted_id
    return org_data

# Lead endpoints
@app.get("/api/leads")
async def get_leads(org_id: Optional[str] = None):
    query = {"org_id": org_id} if org_id else {}
    leads = await db.leads.find(query).to_list(length=100)
    for lead in leads:
        lead["id"] = str(lead["_id"])
    return leads

@app.post("/api/leads")
async def create_lead(lead_data: Dict[str, Any]):
    result = await db.leads.insert_one(lead_data)
    lead_data["_id"] = result.inserted_id
    return lead_data

@app.get("/api/leads/{lead_id}")
async def get_lead(lead_id: str):
    lead = await db.leads.find_one({"_id": lead_id})
    if not lead:
        raise HTTPException(status_code=404, detail="Lead not found")
    lead["id"] = str(lead["_id"])
    return lead

# Conversation endpoints
@app.get("/api/conversations")
async def get_conversations(lead_id: Optional[str] = None):
    query = {"lead_id": lead_id} if lead_id else {}
    conversations = await db.conversations.find(query).to_list(length=100)
    for convo in conversations:
        convo["id"] = str(convo["_id"])
    return conversations

@app.post("/api/conversations/process")
async def process_message(
    message: str = Body(...),
    lead_id: str = Body(...),
    channel: str = Body(..., description="chat, sms, email, voice"),
    org_id: str = Body(...)
):
    # Get lead data
    lead = await db.leads.find_one({"_id": lead_id})
    if not lead:
        raise HTTPException(status_code=404, detail="Lead not found")
    
    # Mock processing for demo
    conversation_id = str(uuid.uuid4())
    response = "This is a mock response from the AI. In the real implementation, this would be generated by the multi-agent system."
    
    # Store conversation in database
    convo_data = {
        "_id": conversation_id,
        "lead_id": lead_id,
        "channel": channel,
        "agent_type": "mock_agent",
        "message": message,
        "response": response,
        "created_at": datetime.now()
    }
    await db.conversations.insert_one(convo_data)
    
    # Return mock response
    return {
        "conversation": convo_data,
        "agent_used": {
            "type": "mock_agent",
            "name": "Mock Agent",
            "description": "A mock agent for testing"
        },
        "response": {
            "response": response,
            "agent_type": "mock_agent",
            "confidence": 0.95,
            "analysis": {
                "intent_detected": "information_request",
                "sentiment": "neutral",
                "next_best_action": "follow_up"
            },
            "timestamp": datetime.now().isoformat()
        }
    }

# API Keys management
@app.get("/api/settings/api-keys/{org_id}")
async def get_organization_api_keys(org_id: str):
    api_keys = await db.api_keys.find_one({"org_id": org_id})
    
    # Mask sensitive data
    masked_keys = {}
    if api_keys:
        for key_name, key_value in api_keys.items():
            if key_name.endswith("_api_key") or key_name.endswith("_api_secret"):
                # Show only last 4 characters
                masked_keys[key_name] = "••••••••" + key_value[-4:] if len(key_value) > 4 else "••••"
            else:
                masked_keys[key_name] = key_value
    
    return masked_keys

@app.put("/api/settings/api-keys/{org_id}")
async def update_organization_api_keys(org_id: str, keys_data: Dict[str, Any]):
    # Filter out None values
    update_data = {k: v for k, v in keys_data.items() if v is not None}
    update_data["org_id"] = org_id
    update_data["updated_at"] = datetime.now()
    
    # Update in database
    result = await db.api_keys.update_one(
        {"org_id": org_id},
        {"$set": update_data},
        upsert=True
    )
    
    # Get updated keys
    api_keys = await db.api_keys.find_one({"org_id": org_id})
    
    # Mask sensitive data in response
    masked_result = {}
    for key_name, key_value in api_keys.items():
        if key_name.endswith("_api_key") or key_name.endswith("_api_secret"):
            # Show only last 4 characters
            masked_result[key_name] = "••••••••" + key_value[-4:] if len(key_value) > 4 else "••••"
        else:
            masked_result[key_name] = key_value
    
    return masked_result

# Placeholder endpoints for the full implementation
@app.get("/api/memory/lead/{lead_id}")
async def get_lead_memory(lead_id: str):
    return {
        "lead_id": lead_id,
        "memory": {
            "factual": {
                "property_preferences": {
                    "bedrooms": 3,
                    "bathrooms": 2,
                    "location": "downtown",
                    "property_type": "condo"
                },
                "budget": {
                    "min": 300000,
                    "max": 450000
                }
            },
            "emotional": {
                "trust_level": 0.7,
                "rapport_level": 0.6
            }
        }
    }

@app.get("/api/agents/config")
async def get_agent_configs():
    return {
        "initial_contact": {
            "name": "Initial Contact Agent",
            "description": "Specializes in first impressions and rapport building",
            "llm_provider": "openai",
            "llm_model": "gpt-4o",
            "temperature": 0.7
        },
        "qualifier": {
            "name": "Qualification Agent",
            "description": "Specializes in lead qualification and needs assessment",
            "llm_provider": "anthropic",
            "llm_model": "claude-3-sonnet",
            "temperature": 0.6
        }
    }

@app.get("/api/knowledge/agent/{agent_type}")
async def get_agent_knowledge(agent_type: str, org_id: str):
    return {
        "examples": [
            {
                "scenario": "Cold call",
                "response": "Hi [Name], this is [Your Name] from [Company]. I noticed you were looking at properties in [Area]. Is this a good time to chat briefly about your real estate needs?"
            }
        ],
        "guidelines": {
            "Initial Contact Best Practices": "When making initial contact with a lead, focus on building rapport and understanding their needs..."
        },
        "common_scenarios": {
            "What is a down payment?": "A down payment is the initial payment made when purchasing a home...",
            "How much do I need for a down payment?": "Typically, you need 3-20% of the purchase price..."
        }
    }

# Shutdown event to close database connection
@app.on_event("shutdown")
async def shutdown_db_client():
    client.close()
