from fastapi import FastAPI, HTTPException, Depends, Query, Body, Header, Request
from fastapi.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
from typing import List, Dict, Any, Optional
import logging
import os
import json
import time
import uuid
from datetime import datetime
from dotenv import load_dotenv
from pathlib import Path

# Load environment variables
ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# MongoDB connection
mongo_url = os.environ.get('MONGO_URL')
db_name = os.environ.get('DB_NAME', 'ai_closer_db')
client = AsyncIOMotorClient(mongo_url)
db = client[db_name]

# Import GHL integration
from ghl import GHLIntegration

# Initialize GHL integration
ghl_integration = GHLIntegration()

# Create FastAPI app
app = FastAPI(title="AI Closer API", version="1.0.0")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Root endpoint
@app.get("/api")
async def root():
    return {"message": "Welcome to AI Closer API", "version": "1.0.0"}

# Organization endpoints
@app.get("/api/organizations")
async def get_organizations():
    orgs = await db.organizations.find().to_list(length=100)
    for org in orgs:
        org["id"] = str(org["_id"])
    return orgs

@app.post("/api/organizations")
async def create_organization(org_data: Dict[str, Any]):
    result = await db.organizations.insert_one(org_data)
    org_data["_id"] = result.inserted_id
    return org_data

# Lead endpoints
@app.get("/api/leads")
async def get_leads(org_id: Optional[str] = None):
    query = {"org_id": org_id} if org_id else {}
    leads = await db.leads.find(query).to_list(length=100)
    for lead in leads:
        lead["id"] = str(lead["_id"])
    return leads

@app.post("/api/leads")
async def create_lead(lead_data: Dict[str, Any]):
    result = await db.leads.insert_one(lead_data)
    lead_data["_id"] = result.inserted_id
    return lead_data

@app.get("/api/leads/{lead_id}")
async def get_lead(lead_id: str):
    lead = await db.leads.find_one({"_id": lead_id})
    if not lead:
        raise HTTPException(status_code=404, detail="Lead not found")
    lead["id"] = str(lead["_id"])
    return lead

# Conversation endpoints
@app.get("/api/conversations")
async def get_conversations(lead_id: Optional[str] = None):
    query = {"lead_id": lead_id} if lead_id else {}
    conversations = await db.conversations.find(query).to_list(length=100)
    for convo in conversations:
        convo["id"] = str(convo["_id"])
    return conversations

@app.post("/api/conversations/process")
async def process_message(
    message: str = Body(...),
    lead_id: str = Body(...),
    channel: str = Body(..., description="chat, sms, email, voice"),
    org_id: str = Body(...)
):
    # Get lead data
    lead = await db.leads.find_one({"_id": lead_id})
    if not lead:
        raise HTTPException(status_code=404, detail="Lead not found")
    
    # Mock processing for demo
    conversation_id = str(uuid.uuid4())
    response = "This is a mock response from the AI. In the real implementation, this would be generated by the multi-agent system."
    
    # Store conversation in database
    convo_data = {
        "_id": conversation_id,
        "lead_id": lead_id,
        "channel": channel,
        "agent_type": "mock_agent",
        "message": message,
        "response": response,
        "created_at": datetime.now()
    }
    await db.conversations.insert_one(convo_data)
    
    # Return mock response
    return {
        "conversation": convo_data,
        "agent_used": {
            "type": "mock_agent",
            "name": "Mock Agent",
            "description": "A mock agent for testing"
        },
        "response": {
            "response": response,
            "agent_type": "mock_agent",
            "confidence": 0.95,
            "analysis": {
                "intent_detected": "information_request",
                "sentiment": "neutral",
                "next_best_action": "follow_up"
            },
            "timestamp": datetime.now().isoformat()
        }
    }

# API Keys management
@app.get("/api/settings/api-keys/{org_id}")
async def get_organization_api_keys(org_id: str):
    api_keys = await db.api_keys.find_one({"org_id": org_id})
    if not api_keys:
        return {}
    
    # Mask sensitive data
    masked_keys = {}
    for key_name, key_value in api_keys.items():
        if (key_name.endswith("_api_key") or key_name.endswith("_secret") or key_name.endswith("_client_secret")) and key_value:
            # Show only last 4 characters
            masked_keys[key_name] = "••••••••" + key_value[-4:] if len(key_value) > 4 else "••••"
        else:
            masked_keys[key_name] = key_value
    
    return masked_keys

@app.put("/api/settings/api-keys/{org_id}")
async def update_organization_api_keys(org_id: str, keys_data: Dict[str, Any]):
    keys_data["org_id"] = org_id
    keys_data["updated_at"] = datetime.now()
    
    # Update GHL integration with new credentials if provided
    if "ghl_client_id" in keys_data and "ghl_client_secret" in keys_data and "ghl_shared_secret" in keys_data:
        ghl_integration.set_credentials(
            client_id=keys_data["ghl_client_id"],
            client_secret=keys_data["ghl_client_secret"],
            shared_secret=keys_data["ghl_shared_secret"]
        )
    
    result = await db.api_keys.update_one(
        {"org_id": org_id},
        {"$set": keys_data},
        upsert=True
    )
    
    api_keys = await db.api_keys.find_one({"org_id": org_id})
    
    # Mask sensitive data in response
    masked_result = {}
    for key_name, key_value in api_keys.items():
        if (key_name.endswith("_api_key") or key_name.endswith("_secret") or key_name.endswith("_client_secret")) and key_value:
            # Show only last 4 characters
            masked_result[key_name] = "••••••••" + key_value[-4:] if len(key_value) > 4 else "••••"
        else:
            masked_result[key_name] = key_value
    
    return masked_result

# GHL OAuth endpoints
@app.get("/api/ghl/oauth-url")
async def get_ghl_oauth_url(org_id: str):
    # Get the GHL credentials
    api_keys = await db.api_keys.find_one({"org_id": org_id})
    if not api_keys or "ghl_client_id" not in api_keys:
        raise HTTPException(status_code=400, detail="GHL Client ID not configured")
    
    # Set up GHL integration
    ghl_integration.set_credentials(
        client_id=api_keys["ghl_client_id"],
        client_secret=api_keys.get("ghl_client_secret", ""),
        shared_secret=api_keys.get("ghl_shared_secret", "")
    )
    
    # Generate OAuth URL
    redirect_uri = f"{os.environ.get('FRONTEND_URL', 'http://localhost:3000')}/ghl-callback"
    oauth_url = await ghl_integration.get_oauth_url(redirect_uri)
    
    return {"oauth_url": oauth_url}

@app.post("/api/ghl/oauth-callback")
async def ghl_oauth_callback(org_id: str, code: str):
    # Get the GHL credentials
    api_keys = await db.api_keys.find_one({"org_id": org_id})
    if not api_keys or "ghl_client_id" not in api_keys or "ghl_client_secret" not in api_keys:
        raise HTTPException(status_code=400, detail="GHL OAuth credentials not configured")
    
    # Set up GHL integration
    ghl_integration.set_credentials(
        client_id=api_keys["ghl_client_id"],
        client_secret=api_keys["ghl_client_secret"],
        shared_secret=api_keys.get("ghl_shared_secret", "")
    )
    
    # Exchange code for token
    redirect_uri = f"{os.environ.get('FRONTEND_URL', 'http://localhost:3000')}/ghl-callback"
    try:
        token_data = await ghl_integration.exchange_code_for_token(code, redirect_uri)
        
        # Store tokens in database
        await db.api_keys.update_one(
            {"org_id": org_id},
            {"$set": {
                "ghl_access_token": token_data["access_token"],
                "ghl_refresh_token": token_data["refresh_token"],
                "ghl_token_expires_at": int(time.time()) + token_data["expires_in"],
                "ghl_location_id": token_data.get("locationId", ""),
                "ghl_company_id": token_data.get("companyId", ""),
                "updated_at": datetime.now()
            }}
        )
        
        return {"success": True, "message": "GHL account connected successfully"}
    except Exception as e:
        logger.error(f"Error exchanging GHL OAuth code: {e}")
        raise HTTPException(status_code=500, detail=f"Error connecting GHL account: {str(e)}")

# Placeholder endpoints for the full implementation
@app.get("/api/memory/lead/{lead_id}")
async def get_lead_memory(lead_id: str):
    return {
        "lead_id": lead_id,
        "memory": {
            "factual": {
                "property_preferences": {
                    "bedrooms": 3,
                    "bathrooms": 2,
                    "location": "downtown",
                    "property_type": "condo"
                },
                "budget": {
                    "min": 300000,
                    "max": 450000
                }
            },
            "emotional": {
                "trust_level": 0.7,
                "rapport_level": 0.6
            }
        }
    }

@app.get("/api/agents/config")
async def get_agent_configs():
    return {
        "initial_contact": {
            "name": "Initial Contact Agent",
            "description": "Specializes in first impressions and rapport building",
            "llm_provider": "openai",
            "llm_model": "gpt-4o",
            "temperature": 0.7
        },
        "qualifier": {
            "name": "Qualification Agent",
            "description": "Specializes in lead qualification and needs assessment",
            "llm_provider": "anthropic",
            "llm_model": "claude-3-sonnet",
            "temperature": 0.6
        }
    }

@app.get("/api/knowledge/agent/{agent_type}")
async def get_agent_knowledge(agent_type: str, org_id: str):
    return {
        "examples": [
            {
                "scenario": "Cold call",
                "response": "Hi [Name], this is [Your Name] from [Company]. I noticed you were looking at properties in [Area]. Is this a good time to chat briefly about your real estate needs?"
            }
        ],
        "guidelines": {
            "Initial Contact Best Practices": "When making initial contact with a lead, focus on building rapport and understanding their needs..."
        },
        "common_scenarios": {
            "What is a down payment?": "A down payment is the initial payment made when purchasing a home...",
            "How much do I need for a down payment?": "Typically, you need 3-20% of the purchase price..."
        }
    }

# Shutdown event to close database connection
@app.on_event("shutdown")
async def shutdown_db_client():
    client.close()
